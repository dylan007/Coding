/*=======================
Author    : Shounak Dey
Filename  : aliencow.cpp
=======================	*/

#include<bits/stdc++.h>

using namespace std;

typedef long long int ll;
typedef unsigned long long int ull;

#define PB push_back
#define MK make_pair 
#define SZ(a) (int)(sizeof(a))
#define F first
#define S second
#define FOR(i,a,b) for(int i=a;i<b;i++)
#define REP(i,n) for(int i=0;i<n;i++)
#define read(n) scanf("%d",&n)
#define readl(n) scanf("%lld",&n)
#define readul(n) scanf("%llu",&n);


#define SORTV(a) sort(a.begin(),a.end())
#define TEST int Test;cin >> Test;while(Test--)
#define gcd(a,b) __gcd(a,b)
#define ffs(a) __builtin_ffs(a) // find first set
#define clz(a) __builtin_clz(a) // count leading zeroes
#define ctz(a) __builtin_ctz(a) // count trailing zeroes
#define popc(a) __builtin_popcount(a) // count set bits
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL)


#define error(args...) { vector<string> _v = split(#args, ','); err(_v.begin(), args); }

vector<string> split(const string& s, char c) {
	vector<string> v;
	stringstream ss(s);
	string x;
	while (getline(ss, x, c))
		v.emplace_back(x);
	return move(v);
}

void err(vector<string>::iterator it) {}
template<typename T, typename... Args>
void err(vector<string>::iterator it, T a, Args... args) {
	cerr << it -> substr((*it)[0] == ' ', it -> length()) << " = " << a << '\n';
	err(++it, args...);
}
#define MAXN 100000

//Use DSU with size heuristic to combine all connected components.
vector<ll> parent(MAXN),size(MAXN,-1);
//Define DSU functions
ll find(ll x){
	if(parent[x]!=x)
		parent[x] = find(parent[x]);
	return parent[x];
}

void un(ll x,ll y){
	ll rootx = find(x);
	ll rooty = find(y);
	if(rootx != rooty){
		if(size[rootx]>size[rooty]){
			parent[rooty] = rootx;
			size[rootx] += size[rooty];
		}
		else{
			parent[rootx] = rooty;
			size[rooty] += size[rootx];
		}
	}
}


//Define structures

//Block: (x1,y1)->Coordinates of lower left vertex. (x2,y2)-> Coordinates of the other end point
typedef struct block{
	ll x1,x2,y1,y2;
}block;

//Seg: (x1,y1)->endpoint which is smaller in value. (x2,y2)->The other endpoint
typedef struct seg{
	ll x1,x2,y1,y2;
}seg;



//Define corresponding functions
block def_block(ll x1,ll x2,ll y1,ll y2){
	block tmp;
	tmp.x1 = x1;
	tmp.x2 = x2;
	tmp.y1 = y1;
	tmp.y2 = y2;
	return tmp;
}
void print_block(block tmp){
	cout << "x1: " << tmp.x1 << " y1: " << tmp.y1 << " x2: " << tmp.x2 << " y2: " << tmp.y2 << endl;
}

seg def_segment(ll x1,ll x2,ll y1,ll y2){
	seg tmp;
	tmp.x1 = x1;
	tmp.x2 = x2;
	tmp.y1 = y1;
	tmp.y2 = y2;
	return tmp;
}
void print_segment(seg tmp){
	cout << "x1: " << tmp.x1 << " y1: " << tmp.y1 << " x2: " << tmp.x2 << " y2: " << tmp.y2 << endl;
}

//Define Modular functions
#define MOD 1000000007

ll modexp(ll a,ll b){
	ll ans=1;
	while(b){
		if(b&1)
			ans = (ans * a)%MOD;
		a = (a*a)%MOD;
		b >>= 1;
	}
	return ans;
}

ll modinv(ll a){
	return modexp(a,MOD-2);
}

ll add(ll a,ll b){
	return (a + b)%MOD;
}

int main()
{
	fast_io;
	TEST{
		//Input
		ll n,m,k;
		cin >> n >> m >> k;
		vector<block> fence(k);
		REP(i,k)
			cin >> fence[i].x1 >> fence[i].y1 >> fence[i].x2 >> fence[i].y2;
		
		//1.Buidling the horizontal and vertical extensions and breaking down the coordinate plane into 
		//	blocks of smaller pieces.
		
		//1.1 Finding the distinct x and y coordinates at which extensions can be drawn. T = O(k*log(k))
		set<ll> distx,disty;
		distx.insert(0);
		distx.insert(n);
		disty.insert(0);
		disty.insert(m);
		REP(i,k){
			distx.insert(fence[i].x1);
			distx.insert(fence[i].x2);
			disty.insert(fence[i].y1);
			disty.insert(fence[i].y2);
		}
		//	Create vectors from the set to make them iterable. O(k * log(k))
		vector<ll> vectx,vecty;
		for(auto it:distx)
			vectx.PB(it);
		for(auto it:disty)
			vecty.PB(it);

		//Create Blocks
		//1.2 For every consecutive x and y pairs, create a corresponding block. O(k^2)
		vector<block> piece;
		REP(i,vectx.size()-1){
			FOR(j,1,vecty.size()){
				ll xl,xr,yl,yr;
				xl = vectx[i];
				xr = vectx[i+1];
				yl = vecty[j-1];
				yr = vecty[j];
				piece.PB(def_block(xl,xr,yl,yr));
			}
		}

		//Create a set of line segments generated from the fences to enable quick checking of existing fences.
		//2.1 Insert segments generated by each side of the fence into a set. O(k)
		auto cmp = [](seg a,seg b){
			return (a.x1<b.x1)||(a.x2<b.x2)||(a.y1<b.y1)||(a.y2<b.y2);
		};

		set<seg,decltype(cmp)> seg_set(cmp); 
		for(auto it:fence){
			seg_set.insert(def_segment(it.x1,it.x2,it.y1,it.y1));
			seg_set.insert(def_segment(it.x1,it.x2,it.y2,it.y2));
			seg_set.insert(def_segment(it.x1,it.x1,it.y1,it.y2));
			seg_set.insert(def_segment(it.x2,it.x2,it.y1,it.y2));
		}
		//2.2 Vectorize the generated set. O(k)
		vector<seg> segments;
		for(auto it: seg_set)
			segments.PB(it);
		

		//3. Build the graph such that each block is a node and an edge between two nodes exists if there are
		//	 no fences between them. Each connected component is a single area.
		
		//Define functions to check for adjacency and get the corresponding common segment.
		auto adjacent = [](block a,block b){
			if(a.x1==b.x1 && a.x2==b.x2)
				return ((a.y1==b.y2) || (a.y2==b.y1));
			else if(a.y1==b.y1 && a.y2==b.y2)
				return ((a.x1==b.x2) || (a.x2==b.x1));
			return false;
		};

		auto get_common_edge = [](block a,block b){
			seg tmp;
			if(a.x1==b.x1 && a.x2==b.x2){
				tmp.x1 = a.x1;
				tmp.x2 = a.x2;
				if(a.y1==b.y2)
					tmp.y1=tmp.y2=a.y1;
				else
					tmp.y1=tmp.y2=a.y2;
			}
			else{
				tmp.y1 = a.y1;
				tmp.y2 = a.y2;
				if(a.x1==b.x2)
					tmp.x1=tmp.x2=a.x1;
				else
					tmp.x1=tmp.x2=a.x2;	
			}
			return tmp;
		};

		//Define Container function for two segments. Check if segment A contains segment B.
		auto contains = [](seg a,seg b){
			if(a.x1==a.x2 && a.x1==b.x1 && b.x1==b.x2) 					//Vertical Segment
				return (a.y1<=b.y1 && a.y2>=b.y2);	
			else if(a.y1==a.y2 && b.y1==b.y2 && a.y1==b.y1)				//Horizontal Segment
				return (a.x1<=b.x1 && a.x2>=b.x2);
			return false;
		};


		//Initialize DSU values.
		REP(i,piece.size()){
			size[i] = 1;
			parent[i] = i;
		}

		//Apply DSU on the blocks to find all connected components. O(k^4)
		REP(i,piece.size()){
			FOR(j,i+1,piece.size()){
				if(adjacent(piece[i],piece[j])){
					seg edge = get_common_edge(piece[i],piece[j]);
					ll contained = 0;
					for(auto it: segments){
						//Check if the commomn edge between two blocks is contained by any of the fenced segments.
						if(contains(it,edge)){
							contained = 1;
							break;
						}
					}
					if(!contained)		// No fence between the two blocks.
						un(i,j);		//Combine the two nodes.
				}
			}
		}

		//finalize parent array.
		REP(i,piece.size())
			ll tmp = find(i);

		auto area = [](block a){
			return ((a.x2-a.x1)*(a.y2-a.y1))%MOD;
		};

		// 4. Calculate Final Answer.
		// Combine the areas which belong to the same connected component.
		map<ll,ll> areas;
		REP(i,piece.size()){
			if(areas.find(parent[i]) == areas.end())
				areas[parent[i]] = area(piece[i]);
			else
				areas[parent[i]] = add(areas[parent[i]],area(piece[i]));
		}

		ll num = 0,denum = (n*m)%MOD;
		for(auto it: areas){
			// cout << it.second << endl;
			num = add(num,modexp(it.second,2));
		}
		cout << (num*modinv(denum))%MOD << endl;
	}
	return 0;
}